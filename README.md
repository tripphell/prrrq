# Сидоров Егор УИБО-14-24
# Сортировка выбором (Selection Sort)
Данный способ упорядочивания заключается в систематическом поиске самого маленького значения в несортированной части коллекции, после чего этот элемент перемещается в начало. Массив фактически разделяется на отсортированную и неотсортированную части. Алгоритм выполняет следующие шаги:

Определяем минимальный элемент в остатке массива.

Меняем местами этот элемент с первым элементом в несортированной области.

Продолжаем процесс, пока весь список не будет отсортирован.
Временная затратность достигает порядка 
O
(
n
2
)
O(n 
2
 ), потому что используются вложенные циклы: внешний проходит по всему массиву, внутренний — находит минимум.

# Сортировка пузырьком (Bubble Sort)
Этот метод базируется на сравнении соседних элементов друг с другом и обмене их, если они расположены в неправильном порядке. После каждого прохода самый крупный элемент постепенно перемещается в конец. Ход алгоритма:

Последовательно сравниваем пары соседних значений и меняем их местами при необходимости.

Область проверяемых элементов уменьшается после каждой итерации.

Если за полный проход перестановок не происходит — сортировка завершается.
По эффективности занимает 
O
(
n
2
)
O(n 
2
 ), что делает его неоптимальным для обработки больших массивов.

# Сортировка вставками (Insertion Sort)
Основана на формировании упорядоченной части массива, куда поочерёдно добавляются новые элементы в нужную позицию.

Начинается с одного отсортированного элемента.

Последующие значения по очереди сравниваются с уже отсортированными.

При необходимости элементы смещаются вправо для освобождения места под вставляемый элемент.
Сложность достигает 
O
(
n
2
)
O(n 
2
 ) из-за множества сравнений и сдвигов.

# Сортировка слиянием (Merge Sort)
Алгоритм делит исходные данные на две части и сортирует их отдельно, затем объединяет обратно.

Изначальный набор делится на две половины.

Каждая из них рекурсивно сортируется.

Объединённые отсортированные части формируют итоговую последовательность.
Временные затраты — 
O
(
n
log
⁡
n
)
O(nlogn) благодаря многоуровневой рекурсии и эффективному слиянию.

# Сортировка Шелла (Shell Sort)
Модификация сортировки вставками, но сравнения производятся не между соседними элементами, а с шагом.

Начальный интервал обычно равен половине длины массива.

На каждом шаге выполняется вставочная сортировка через выбранный интервал.

Шаг постепенно уменьшается до 1, что упрощает финальную сортировку на почти отсортированных данных.
Производительность зависит от последовательности интервалов и варьируется от 
O
(
n
log
⁡
2
n
)
O(nlog 
2
 n) до 
O
(
n
2
)
O(n 
2
 ).

# Быстрая сортировка (Quick Sort)
Применяет принцип «разделяй и властвуй».

Выбирается опорный элемент (pivot).

Массив разделяется на два подмассива: элементы меньше pivot и больше pivot.

Каждая часть сортируется отдельно рекурсивным вызовом.
Средняя скорость работы — 
O
(
n
log
⁡
n
)
O(nlogn), но в худшем случае при неудачном выборе опорного элемента — 
O
(
n
2
)
O(n 
2
 ).

# Пирамидальная сортировка (Heap Sort)
Использует структуру данных в виде двоичной кучи для упорядочивания.

Массив преобразуется в максимальную кучу, где у каждого родителя значение больше потомков.

Корневой элемент меняется с последним элементом массива.

Размер кучи уменьшается, структура восстанавливается.

Операция повторяется до полной сортировки.
Гарантированное время работы — 
O
(
n
log
⁡
n
)
O(nlogn).

# Последовательный поиск (Linear Search)
Простейший способ нахождения элемента путём проверки каждого значения по очереди.

Линейно перебираем все элементы.

При совпадении возвращаем индекс.

Если элемент отсутствует, возвращаем -1.
Сложность — 
O
(
n
)
O(n).

# Бинарный поиск (Binary Search)
Работает на отсортированных массивах, каждый раз деля область поиска пополам.

Вычисляем средний элемент текущего диапазона.

Если он совпадает с искомым — возвращаем позицию.

Если искомый меньше срединного, повторяем поиск в левой половине, иначе в правой.
Время поиска — 
O
(
log
⁡
n
)
O(logn).

# Интерполяционный поиск (Interpolation Search)
Подобен бинарному, но вместо середины выбирает предположительное местоположение элемента на основе интерполяции.

Рассчитывается индекс, исходя из значения элемента и границ диапазона.

Позиция проверяется и границы корректируются.

Повторяется до нахождения или опустошения диапазона.
Сложность колеблется от 
O
(
log
⁡
log
⁡
n
)
O(loglogn) при равномерных данных до 
O
(
n
)
O(n) в худших случаях.

# Поиск с помощью чисел Фибоначчи (Fibonacci Search)
Основан на числах Фибоначчи для определения точек разбиения массива.

Ищем минимальное число Фибоначчи, большее длины массива.

Массив делится вдоль индексов, соответствующих числам Фибоначчи.

Сравниваем искомый элемент с элементом в этих позициях.

По мере сужения области продолжаем поиск в подмассиве.
Средняя скорость — 
O
(
log
⁡
n
)
O(logn), иногда работает быстрее традиционного бинарного поиска.
